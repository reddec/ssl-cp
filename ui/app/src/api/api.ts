/* tslint:disable */
/* eslint-disable */
/**
 * SSL-CP
 * SSL-CP API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {Subject}
     * @memberof Batch
     */
    certificate?: Subject;
    /**
     * Child certificates (issuer ID will be ignored). If nested not null or issuer is 0, then CA=true will be forced. 
     * @type {Array<Batch>}
     * @memberof Batch
     */
    nested?: Array<Batch>;
}
/**
 * 
 * @export
 * @interface Certificate
 */
export interface Certificate {
    /**
     * Global unique ID that will not change after renewal
     * @type {number}
     * @memberof Certificate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    serial?: string;
    /**
     * 
     * @type {number}
     * @memberof Certificate
     */
    issuer?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Certificate
     */
    ca?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    domains?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    expire_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    revoked_at?: string;
    /**
     * Organization units
     * @type {Array<string>}
     * @memberof Certificate
     */
    units?: Array<string>;
}
/**
 * 
 * @export
 * @interface Renewal
 */
export interface Renewal {
    /**
     * 
     * @type {number}
     * @memberof Renewal
     */
    days?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Renewal
     */
    domains?: Array<string>;
    /**
     * Organization units
     * @type {Array<string>}
     * @memberof Renewal
     */
    units?: Array<string>;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Total number of issued certificates
     * @type {number}
     * @memberof Status
     */
    total?: number;
    /**
     * Total number of expired certificates
     * @type {number}
     * @memberof Status
     */
    expired?: number;
    /**
     * Total number of certificates that will soon expire (within 30 days)
     * @type {number}
     * @memberof Status
     */
    soon_expire?: number;
    /**
     * Total number of central authorities
     * @type {number}
     * @memberof Status
     */
    ca?: number;
    /**
     * Total number of revoke certificates
     * @type {number}
     * @memberof Status
     */
    revoked?: number;
}
/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * 
     * @type {string}
     * @memberof Subject
     */
    name?: string;
    /**
     * Parent CA certificate ID
     * @type {number}
     * @memberof Subject
     */
    issuer?: number;
    /**
     * 
     * @type {number}
     * @memberof Subject
     */
    days?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Subject
     */
    ca?: boolean;
    /**
     * SAN for the certificate. If not defined - name will be used
     * @type {Array<string>}
     * @memberof Subject
     */
    domains?: Array<string>;
    /**
     * Organization units
     * @type {Array<string>}
     * @memberof Subject
     */
    units?: Array<string>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create multiple certificates 
         * @param {Array<Batch>} [batch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateCertificate: async (batch?: Array<Batch>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create root (issuer id 0) or child certificate. Child certificate can be issued only if issuer referred to CA cert. Root certificates always CA (ca flag ignored). 
         * @param {Subject} [subject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCertificate: async (subject?: Subject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get issued certificate 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('getCertificate', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get certificate private part 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivateKey: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('getPrivateKey', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}/key`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get certificate public part 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCert: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('getPublicCert', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}/cert`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Certificate Revoked List. Make senses only for CA. 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevokedCertificatesList: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('getRevokedCertificatesList', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}/revoked/crl`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get general status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get issued child certificates. Applicable only for CA certificates. Special ID=0 means root certificates 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCertificates: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('listCertificates', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}/issued`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List expired certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExpiredCertificates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/certificates/expired`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List certificates revoked for the certificate. Make senses only for CA. 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRevokedCertificates: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('listRevokedCertificates', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}/revoked`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List root certificates (without issuers). Equal to /certificates/0/issued
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRootCertificates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List certificates wich will soon expire (within 30 days by default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSoonExpireCertificates: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/certificates/soon-expire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-create certificate with same parameters but with different expiration. In case of CA it will cause cascade renewal. 
         * @param {number} certificateId 
         * @param {Renewal} [renewal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewCertificate: async (certificateId: number, renewal?: Renewal, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('renewCertificate', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renewal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke issued certificate 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCertificate: async (certificateId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificateId' is not null or undefined
            assertParamExists('revokeCertificate', 'certificateId', certificateId)
            const localVarPath = `/certificate/{certificate_id}`
                .replace(`{${"certificate_id"}}`, encodeURIComponent(String(certificateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Create multiple certificates 
         * @param {Array<Batch>} [batch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchCreateCertificate(batch?: Array<Batch>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Certificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchCreateCertificate(batch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create root (issuer id 0) or child certificate. Child certificate can be issued only if issuer referred to CA cert. Root certificates always CA (ca flag ignored). 
         * @param {Subject} [subject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCertificate(subject?: Subject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Certificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCertificate(subject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get issued certificate 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCertificate(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Certificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCertificate(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get certificate private part 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrivateKey(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrivateKey(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get certificate public part 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicCert(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicCert(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Certificate Revoked List. Make senses only for CA. 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevokedCertificatesList(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevokedCertificatesList(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get general status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get issued child certificates. Applicable only for CA certificates. Special ID=0 means root certificates 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCertificates(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Certificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCertificates(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List expired certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExpiredCertificates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Certificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExpiredCertificates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List certificates revoked for the certificate. Make senses only for CA. 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRevokedCertificates(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Certificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRevokedCertificates(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List root certificates (without issuers). Equal to /certificates/0/issued
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRootCertificates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Certificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRootCertificates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List certificates wich will soon expire (within 30 days by default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSoonExpireCertificates(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Certificate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSoonExpireCertificates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Re-create certificate with same parameters but with different expiration. In case of CA it will cause cascade renewal. 
         * @param {number} certificateId 
         * @param {Renewal} [renewal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renewCertificate(certificateId: number, renewal?: Renewal, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Certificate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renewCertificate(certificateId, renewal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revoke issued certificate 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeCertificate(certificateId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeCertificate(certificateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Create multiple certificates 
         * @param {Array<Batch>} [batch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateCertificate(batch?: Array<Batch>, options?: any): AxiosPromise<Array<Certificate>> {
            return localVarFp.batchCreateCertificate(batch, options).then((request) => request(axios, basePath));
        },
        /**
         * Create root (issuer id 0) or child certificate. Child certificate can be issued only if issuer referred to CA cert. Root certificates always CA (ca flag ignored). 
         * @param {Subject} [subject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCertificate(subject?: Subject, options?: any): AxiosPromise<Certificate> {
            return localVarFp.createCertificate(subject, options).then((request) => request(axios, basePath));
        },
        /**
         * Get issued certificate 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCertificate(certificateId: number, options?: any): AxiosPromise<Certificate> {
            return localVarFp.getCertificate(certificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get certificate private part 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrivateKey(certificateId: number, options?: any): AxiosPromise<string> {
            return localVarFp.getPrivateKey(certificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get certificate public part 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCert(certificateId: number, options?: any): AxiosPromise<string> {
            return localVarFp.getPublicCert(certificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Certificate Revoked List. Make senses only for CA. 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevokedCertificatesList(certificateId: number, options?: any): AxiosPromise<string> {
            return localVarFp.getRevokedCertificatesList(certificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get general status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Status> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get issued child certificates. Applicable only for CA certificates. Special ID=0 means root certificates 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCertificates(certificateId: number, options?: any): AxiosPromise<Array<Certificate>> {
            return localVarFp.listCertificates(certificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * List expired certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExpiredCertificates(options?: any): AxiosPromise<Array<Certificate>> {
            return localVarFp.listExpiredCertificates(options).then((request) => request(axios, basePath));
        },
        /**
         * List certificates revoked for the certificate. Make senses only for CA. 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRevokedCertificates(certificateId: number, options?: any): AxiosPromise<Array<Certificate>> {
            return localVarFp.listRevokedCertificates(certificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * List root certificates (without issuers). Equal to /certificates/0/issued
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRootCertificates(options?: any): AxiosPromise<Array<Certificate>> {
            return localVarFp.listRootCertificates(options).then((request) => request(axios, basePath));
        },
        /**
         * List certificates wich will soon expire (within 30 days by default)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSoonExpireCertificates(options?: any): AxiosPromise<Array<Certificate>> {
            return localVarFp.listSoonExpireCertificates(options).then((request) => request(axios, basePath));
        },
        /**
         * Re-create certificate with same parameters but with different expiration. In case of CA it will cause cascade renewal. 
         * @param {number} certificateId 
         * @param {Renewal} [renewal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewCertificate(certificateId: number, renewal?: Renewal, options?: any): AxiosPromise<Certificate> {
            return localVarFp.renewCertificate(certificateId, renewal, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke issued certificate 
         * @param {number} certificateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeCertificate(certificateId: number, options?: any): AxiosPromise<void> {
            return localVarFp.revokeCertificate(certificateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create multiple certificates 
     * @param {Array<Batch>} [batch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchCreateCertificate(batch?: Array<Batch>, options?: any) {
        return DefaultApiFp(this.configuration).batchCreateCertificate(batch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create root (issuer id 0) or child certificate. Child certificate can be issued only if issuer referred to CA cert. Root certificates always CA (ca flag ignored). 
     * @param {Subject} [subject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCertificate(subject?: Subject, options?: any) {
        return DefaultApiFp(this.configuration).createCertificate(subject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get issued certificate 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCertificate(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).getCertificate(certificateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get certificate private part 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrivateKey(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).getPrivateKey(certificateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get certificate public part 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPublicCert(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).getPublicCert(certificateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Certificate Revoked List. Make senses only for CA. 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRevokedCertificatesList(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).getRevokedCertificatesList(certificateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get general status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatus(options?: any) {
        return DefaultApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get issued child certificates. Applicable only for CA certificates. Special ID=0 means root certificates 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listCertificates(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).listCertificates(certificateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List expired certificates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listExpiredCertificates(options?: any) {
        return DefaultApiFp(this.configuration).listExpiredCertificates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List certificates revoked for the certificate. Make senses only for CA. 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listRevokedCertificates(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).listRevokedCertificates(certificateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List root certificates (without issuers). Equal to /certificates/0/issued
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listRootCertificates(options?: any) {
        return DefaultApiFp(this.configuration).listRootCertificates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List certificates wich will soon expire (within 30 days by default)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSoonExpireCertificates(options?: any) {
        return DefaultApiFp(this.configuration).listSoonExpireCertificates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-create certificate with same parameters but with different expiration. In case of CA it will cause cascade renewal. 
     * @param {number} certificateId 
     * @param {Renewal} [renewal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public renewCertificate(certificateId: number, renewal?: Renewal, options?: any) {
        return DefaultApiFp(this.configuration).renewCertificate(certificateId, renewal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke issued certificate 
     * @param {number} certificateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public revokeCertificate(certificateId: number, options?: any) {
        return DefaultApiFp(this.configuration).revokeCertificate(certificateId, options).then((request) => request(this.axios, this.basePath));
    }
}


